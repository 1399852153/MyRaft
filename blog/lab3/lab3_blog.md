# 手写raft(三) 实现日志压缩
在上一篇博客中MyRaft实现了日志复制功能，按照计划接下来需要实现日志压缩。
* [手写raft(一) 实现leader选举](https://www.cnblogs.com/xiaoxiongcanguan/p/17569697.html)
* [手写raft(二) 实现日志复制](https://www.cnblogs.com/xiaoxiongcanguan/p/17636220.html)
## 1. 什么是raft日志压缩？
我们知道raft协议是基于日志复制的协议，日志数据是raft的核心。但随着raft集群的持续工作，raft的日志文件将会维护越来越多的日志，而这会带来以下几个问题。
1. 日志文件过大会占用所在机器过多的本地磁盘空间。
2. 对于新加入集群的follower，leader与该follower之间完成日志同步会非常缓慢。
3. 对于自身不进行持久化的状态机，raft节点重启后回放日志也会非常缓慢。
#####
考虑到绝大多数的状态机中存储的数据并不都是新增，而更多的是对已有数据的更新，则状态机中所存储的数据量通常会远小于raft日志的总大小。例如K/V数据库，对相同key的N次操作，只有最后一次操作是实际有效的，而在此之前的针对该key的raft日志其实已经没有保存的必要了。  
因此raft的作者在论文的日志压缩一节中提出了几种日志压缩的算法(基于快照的、基于LSM树的)，raft选择了更容易理解和实现的、基于状态机快照的算法作为日志压缩的基础。
todo 日志压缩流程图
## 2. MyRaft日志压缩实现分析
raft日志压缩实现中有以下几个关键点：
* raft的各个节点可以按照某种策略独立的生成快照(比如定期检测日志文件大小是否超过阈值)，快照的主要内容是状态机当前瞬间所维护的所有数据的快照。  
  MyRaft的状态机是一个纯内存的K/V数据库，所以快照就是内存中对应Map数据序列化后的内容。
* 当前状态机中的快照实际上等同于所有已提交日志的顺序执行的最终结果，快照文件生成后会将所有已提交的日志全部删除以达成压缩的目的。  
  而在处理appendEntries时，leader需要在参数中设置当前传输日志的前一条日志的index和term值，如果此时leader前一条日志恰好是已提交的并且被压缩到快照里而被删除了，则获取不到这个值了。  
  相对应的，follower也可能出现类似的情况，即当前所有日志都是已提交的并且由于日志压缩被删除了，进行prevIndex/prevTerm校验时，也需要这个数据。
  因此，最终的快照中包含了最后一条已提交日志的index和term值这一关键的元数据。
* 在leader和日志进度较慢的follower进行通信时，如果follower所需要的日志是很早的，而leader这边对应index的日志又被快照压缩而删除了，没法通过appendEntries进行同步。  
  raft对此新增加了一个rpc接口installSnapshot专门用于解决这个问题。在leader发现follower所需的日志已经被自己压缩到快照里时，则会通过installSnapshot将自己完整的快照直接复制给follower。  
  由于快照可能很大，所以installSnapshot一次只会传输少量的日志，通过多次的交互后完成整个快照的安装。当follower侧完成了快照同步后，后续所需要同步的日志就都是leader日志文件中还保留的，后续的日志接着使用appendEntries同步即可。
#####
  

## 3. MyRaft日志压缩测试case

## 总结